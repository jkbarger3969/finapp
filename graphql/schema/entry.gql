# union EntrySource = Person | Business | Department

enum EntryType {
  CREDIT
  DEBIT
}

type EntryDateOfRecord {
  """
  ISO 8601
  """
  date: Date!
  overrideFiscalYear: Boolean!
}

input EntryDateOfRecordAdd {
  """
  ISO 8601
  """
  date: Date!
  overrideFiscalYear: Boolean!
}
input EntryDateOfRecordUpdate {
  """
  ISO 8601
  """
  date: Date
  overrideFiscalYear: Boolean
  """
  When "clear" field is true, the "date" and "overrideFiscalYear" are ignored.
  When "clear" field is false or null, it is ignored i.e. does nothing.
  """
  clear: Boolean
}

type Entry {
  id: ID!
  category: Category!
  """
  ISO 8601
  """
  date: Date!
  dateOfRecord: EntryDateOfRecord
  deleted: Boolean!
  department: Department!
  description: String
  fiscalYear: FiscalYear!
  items: [EntryItem!]!
  lastUpdate: Date!
  paymentMethod: PaymentMethodInterface!
  reconciled: Boolean!
  refunds: [EntryRefund!]!
  source: Entity!
  total: Rational!
  # type: EntryType!
}

input EntriesWhereSource {
  businesses: BusinessesWhere
  departments: DepartmentsWhere
  people: PeopleWhere
}

input EntriesWhereDateOfRecord {
  date: WhereDateBeta
  overrideFiscalYear: Boolean
}

input EntriesWhere {
  # Fields
  id: WhereId
  refunds: EntryRefundsWhere
  items: EntryItemsWhere
  # type: EntryType
  date: WhereDateBeta
  dateOfRecord: EntriesWhereDateOfRecord
  department: DepartmentsWhere
  fiscalYear: FiscalYearsWhere
  category: CategoriesWhere
  # paymentMethod: PaymentMethodsWhere
  description: WhereRegex
  total: WhereRational
  source: EntriesWhereSource
  reconciled: Boolean
  lastUpdate: WhereDateBeta
  deleted: Boolean

  # Logic
  and: [EntriesWhere!]
  or: [EntriesWhere!]
  nor: [EntriesWhere!]
}

enum SourceType {
  BUSINESS
  DEPARTMENT
  PERSON
}

input SourceInput {
  sourceType: SourceType!
  id: ID!
}

input EntryUpdateFields {
  """
  ISO 8601
  """
  date: Date
  dateOfRecord: EntryDateOfRecordUpdate
  department: ID
  type: EntryType
  category: ID
  paymentMethod: ID
  description: String
  total: Rational
  source: SourceInput
  reconciled: Boolean
}

input EntryAddFields {
  """
  ISO 8601
  """
  date: Date!
  dateOfRecord: EntryDateOfRecordAdd
  department: ID!
  type: EntryType!
  category: ID!
  paymentMethod: ID!
  description: String
  total: Rational!
  source: SourceInput!
  reconciled: Boolean
}

# Refunds
type EntryRefund {
  id: ID!
  """
  ISO 8601
  """
  date: Date!
  deleted: Boolean!
  description: String
  entry: Entry!
  lastUpdate: Date!
  paymentMethod: PaymentMethodInterface!
  reconciled: Boolean!
  total: Rational!
}

input EntryRefundsWhere {
  # Fields
  id: WhereId
  date: WhereDateBeta
  entry: EntriesWhere
  # paymentMethod: PaymentMethodsWhere
  total: WhereRational
  reconciled: Boolean
  lastUpdate: WhereDateBeta
  deleted: Boolean

  # Logic
  and: [EntryRefundsWhere!]
  or: [EntryRefundsWhere!]
  nor: [EntryRefundsWhere!]
}

input EntryAddRefundFields {
  """
  ISO 8601
  """
  date: Date!
  description: String
  paymentMethod: ID!
  total: Rational!
  reconciled: Boolean
}

input EntryUpdateRefundFields {
  """
  ISO 8601
  """
  date: Date
  description: String
  paymentMethod: ID
  total: Rational
  reconciled: Boolean
}

# Items
type EntryItem {
  id: ID!
  category: Category
  deleted: Boolean!
  department: Department
  description: String
  lastUpdate: Date!
  total: Rational!
  units: Int!
}

input EntryItemsWhere {
  # Fields
  id: WhereId
  department: DepartmentsWhere
  category: CategoriesWhere
  units: WhereInt
  total: WhereRational
  lastUpdate: WhereDateBeta
  deleted: Boolean

  # Logic
  and: [EntryItemsWhere!]
  or: [EntryItemsWhere!]
  nor: [EntryItemsWhere!]
}

input EntryAddItemFields {
  department: ID
  category: ID
  description: String
  units: Int!
  total: Rational!
}

input EntryUpdateItemFields {
  department: ID
  category: ID
  description: String
  units: Int
  total: Rational
}

type EntryItemUpsertResult {
  entryItem: EntryItem!
  entry: Entry!
}

type Query {
  entries(where: EntriesWhere): [Entry!]!
  entry(id: ID!): Entry
  entryRefund(id: ID!): EntryRefund
  entryRefunds(where: EntryRefundsWhere): [EntryRefund!]!
  entryItem(id: ID!): EntryItem
}

input EntryUpdatePaymentMethod {
  id: ID!
  # fields: PaymentMethodUpdateFields!
}

type Mutation {
  entryUpdate(
    id: ID!
    fields: EntryUpdateFields!
    """
    paymentMethodAdd and paymentMethodUpdate are mutually exclusive.
    """
    # paymentMethodAdd: PaymentMethodAddFields
    paymentMethodUpdate: EntryUpdatePaymentMethod
    """
    personAdd and businessAdd are mutually exclusive.
    """
    personAdd: PersonAddFields
    businessAdd: BusinessAddFields
  ): Entry!
  entryAdd(
    fields: EntryAddFields!
    # paymentMethodAdd: PaymentMethodAddFields
    personAdd: PersonAddFields
    businessAdd: BusinessAddFields
  ): Entry!
  entryDelete(id: ID!): Entry!
  entryAddRefund(
    id: ID!
    fields: EntryAddRefundFields! # paymentMethodAdd: PaymentMethodAddFields
  ): Entry!
  entryUpdateRefund(
    id: ID!
    fields: EntryUpdateRefundFields!
    # paymentMethodAdd: PaymentMethodAddFields
    paymentMethodUpdate: EntryUpdatePaymentMethod
  ): Entry!
  entryDeleteRefund(id: ID!): Entry!
  entryAddItem(id: ID!, fields: EntryAddItemFields!): EntryItemUpsertResult!
  entryUpdateItem(
    id: ID!
    fields: EntryUpdateItemFields!
  ): EntryItemUpsertResult!
  entryDeleteItem(id: ID!): EntryItemUpsertResult!
}

type Subscription {
  entryAdded: Entry!
  entryUpdated: Entry!
  entryUpserted: Entry!
}
